#!/usr/bin/env node

// This is a Node.js script that interacts with the ChatGPT server
// using Puppeteer, a Node.js library for controlling a headless
// Chrome or Chromium browser. The script provides two modes of
// operation: "send" mode and "receive" mode. 

// In send mode, the script reads a query from standard input, sends
// the query to the ChatGPT server via the browser, and exits. 

// In receive mode, the script waits for a reply from the ChatGPT
// server via the browser, extracts the reply from the browser's HTML,
// converts it to plain text using the html-to-text Node.js library,
// and outputs the plain text to standard output. 

// The script also provides an optional "-i" mode to reload the
// ChatGPT page in the browser. 

// https://pptr.dev/
const puppeteer = require('puppeteer-core');
const convert = require('html-to-text');
const exec = require('child_process').exec

// This function is used for debugging purposes.
function die (msg='aborted') {
    console.log('** ', msg);
    process.exit(1);
}
    
async function sleep (ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
async function connect_to_browser () {
    for (let n = 0; n < 3; n++) {
	try {
	    // FIXME: Port number should be configurable.
	    let browser = await puppeteer.connect({
		browserURL: 'http://localhost:9000',
		defaultViewport: null,
	    });
	    return browser;
	}
	catch (err) {
	    exec('google-chrome --remote-debugging-port=9000', function (error, stdout, stderr) {});
	    await sleep(500);
	}
    }
}

async function current_page () {
    const browser = await connect_to_browser();
    const pages = await browser.pages();
    for (const page of pages) {
	// FIXME: Avoid hard-coding.
	const url = page.url();
	if (url.indexOf('chatgpt.com') > 0) {
	    await page.bringToFront();
	    return page;
	}
    }
    // Open ChatGPT if not already visiting.
    let page = pages[0];
    await page.bringToFront();
    await page.goto('https://chatgpt.com/');
    return page;
}

async function get_text (page, elem) {
    let html = await page.evaluate(el => el.innerHTML, elem);
    let text = convert.convert(html, {
        preserveNewlines: true,
        wordwrap: false,
    });
    return text;
}

async function is_replying (page) {
    // FIXME: This code doesn't work.
    const button = await page.$('button[data-testid="stop-button"]');
    return button;
}

function display_diff (last_reply, reply) {
    let last_lines = last_reply.split('\n');
    let lines = reply.split('\n');
    for (let n = last_lines.length - 1; n < lines.length - 1; n++)
	console.log(lines[n]);
}

async function send_query (query) {
    console.log('connecting to the browser...')
    const page = await current_page();
    console.log('sending query...')
    await page.$eval('#prompt-textarea > p',
		     (el, str) => el.innerText = str, query);
    // Note: Submit button has the data-testid field.
    const button = await page.waitForSelector('button[data-testid="send-button"]');
    await button.click();

    // Wait until reply starts displaying.
    while (!await is_replying(page)) {
	await sleep(200);
    }
    console.log('receiving the reply...')
    // Locate the DIV tag containing the reply.
    let elems = await page.$$('div[data-message-author-role="assistant"]');
    let elem = elems[elems.length - 1];

    let last_reply = '';
    let count = 0;
    let busy = true;
    // Loop 2 seconds after the stop button disapper.
    while (count < 10) {
	if (!await is_replying(page))
	    count++;
	reply = await get_text (page, elem);
	if (reply.length > last_reply.length) { // Any addition?
	    display_diff (last_reply, reply);
	    last_reply = reply;
	}
	await sleep(200);
    }
    // Display the last line.
    let lines = reply.split('\n');
    console.log(lines[lines.length - 1]);
}

// argv[2] is the first user-specified argument.
const mode = process.argv[2];

if (mode == '-i') {
    (async () => {
	const page = await current_page();
	process.exit(0);
    })();
} else if (mode == '-q') {
    (async () => {
	const query = process.argv[3]
	await send_query(query);
	process.exit(0);
    })();
}
