#!/usr/bin/env node

// https://pptr.dev/
const puppeteer = require('puppeteer-core');
const convert = require('html-to-text');
const exec = require('child_process').exec

function debug(msg) {
    process.stdout.write(msg);
}

async function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function connect_to_browser() {
    for (let n = 0; n < 3; n++) {
        try {
            // FIXME: Port number should be configurable.
            const browser = await puppeteer.connect({
                browserURL: 'http://localhost:9000',
                defaultViewport: null,
            });
            return browser;
        } catch (err) {
            exec('google-chrome --remote-debugging-port=9000', function(error, stdout, stderr) {});
            await sleep(500);
        }
    }
}

async function current_page() {
    debug("# connecting...");
    const browser = await connect_to_browser();
    debug("opening...");
    const pages = await browser.pages();
    for (const page of pages) {
        // FIXME: Avoid hard-coding.
        const url = page.url();
        if (url.indexOf('claude.ai') > 0) {
            await page.bringToFront();
            return page;
        }
    }
    // Open ChatGPT if not already visiting.
    const page = pages[0];
    await page.bringToFront();
    await page.goto('https://claude.ai/');
    return page;
}

async function get_text(page, elem) {
    const html = await page.evaluate(el => el.innerHTML, elem);
    let text = convert.convert(html, {
        preserveNewlines: true,
        wordwrap: false,
    });
    text = text.replace(/\n\n+/g, '\n\n');
    // Remove the garbage at the bottom in Claude.
    text = text.replace('\nCopyRetry', '');
    return text;
}

async function is_replying(page) {
    let flag = false;
    try {
	await page.waitForSelector('button[aria-label="Stop Response"]', { 
	    visible: true,
	    timeout: 1
	});
	const button = await page.$('button[aria-label="Stop Response"]');
	const isClickable = await button.evaluate(el => !el.disabled);
	flag = true;
    } catch (error) {
    }
console.log(flag)
    return flag;
}

async function __is_replying(page) {
    const elem = await page.$('body');
    const html = await page.evaluate(el => el.innerHTML, elem);
console.log(html.includes('Claude response'))
    return html.includes('Stop Claude response');
}

async function _is_replying(page) {
    let busy = false;
    try {
	const elem = await page.waitForSelector('button[aria-label="Stop Response"]',
						{ visible: true, timeout: 0 });
	busy = true;
    } catch (err) {
    }
    console.log('is_replying: ', busy)
    return busy;
}

function display_diff(last_reply, reply) {
    const last_lines = last_reply.split('\n');
    const lines = reply.split('\n');
    for (let n = last_lines.length - 1; n < lines.length - 1; n++)
        console.log(lines[n]);
}

async function send_query(query) {
    const page = await current_page();
    debug("sending...");
    let prev_elems = await page.$$('div[data-test-render-count]');
    await page.$eval('p[data-placeholder]',
        (el, str) => el.innerText = str, query);
    const button = await page.waitForSelector('button[aria-label="Send Message"]');
    await button.click();

    // Wait until reply starts displaying.
    let elems;
    while (true) {
        elems = await page.$$('div[data-test-render-count]');
        if (elems.length - prev_elems.length >= 2)
            break;
        await sleep(200);
    }
    debug("done\n");
    const elem = elems[elems.length - 1];

    let last_reply = '';
    let retry_count = 0;
    // Loop one second after the stop button disapper.
    while (retry_count < 10*100) {
        reply = await get_text(page, elem);
        if (reply.length > last_reply.length) { // Any addition?
            display_diff(last_reply, reply);
            last_reply = reply;
	    retry_count = 0;
	} else {
	    if (!await is_replying(page))
		retry_count++;
	}
        await sleep(100);
    }
    // Display the last line.
    const lines = reply.split('\n');
    console.log(lines[lines.length - 1]);
}

// argv[2] is the first user-specified argument.
const mode = process.argv[2];

if (mode == '-i') {
    (async () => {
        const page = await current_page();
        process.exit(0);
    })();
} else if (mode == '-q') {
    (async () => {
        const query = process.argv[3]
        await send_query(query);
        process.exit(0);
    })();
}
