#!/usr/bin/env node

// This is a Node.js script that interacts with the ChatGPT server
// using Puppeteer, a Node.js library for controlling a headless
// Chrome or Chromium browser. The script provides two modes of
// operation: "send" mode and "receive" mode. 

// In send mode, the script reads a query from standard input, sends
// the query to the ChatGPT server via the browser, and exits. 

// In receive mode, the script waits for a reply from the ChatGPT
// server via the browser, extracts the reply from the browser's HTML,
// converts it to plain text using the html-to-text Node.js library,
// and outputs the plain text to standard output. 

// The script also provides an optional "-i" mode to reload the
// ChatGPT page in the browser. 

// https://pptr.dev/
const readline = require('readline');
const puppeteer = require('puppeteer');
const convert = require('html-to-text');

// This function is used for debugging purposes. It takes an optional
// msg argument, which defaults to the string "aborted". It prints a
// message to the console with the prefix "** ", followed by the msg,
// and exits the current process with an exit code of 1.
function die (msg='aborted') {
    console.log('** ', msg);
    process.exit(1);
}
    
// This function provides a delay of a certain number of milliseconds
// before resolving the promise. It takes a single argument ms, which
// specifies the number of milliseconds to wait before the promise is
// resolved. The function returns a Promise object that is resolved
// after the specified time has elapsed.
async function sleep (ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// This function returns a Puppeteer page object for the current tab
// in the browser connected to the ChatGPT website. If the website is
// not already open in the current tab, it opens the website and waits
// for the textarea element to appear on the page. The function also
// connects to the Puppeteer browser using the default port number
// (9000) and returns the first page in the list of available
// pages. The URL of the current page is checked to determine if the
// ChatGPT website is already open. If the ChatGPT website is already
// open in the current tab, the function simply returns the current
// page object.
async function current_page () {
    // FIXME: Port number should be configurable.
    const browser = await puppeteer.connect({browserURL: 'http://localhost:9000'});
    // Find the page in the first tab.
    const pages = await browser.pages();
    let page = pages[0];
    // Open ChatGPT if not already visiting.
    const url = page.url();
    if (url.indexOf('chat.openai.com') < 0) {
	await page.goto('https://chat.openai.com/');
	const text = await page.waitForSelector('textarea');
	await sleep(1000);
    }
    return page;
}

// This asynchronous function takes a page object as input and returns
// the HTML content of the last reply from ChatGPT server. It first
// selects all the div tags with class items-start on the page using
// the $$ method of the page object. It then selects the last element
// from the list of div tags and gets its inner HTML using the
// page.evaluate method. If there are no div tags matching the
// selection criteria, an empty string is returned.
async function extract_reply (page) {
    // Note: All replies are in DIV tags with markdown class.
    const elems = await page.$$('div.items-start');
    const elem = elems[elems.length - 1];
    // Replies might be empty.
    if (!elem)
	return '';
    const html = await page.evaluate(e => e.innerHTML, elem);
    return html;
}
    
// This function checks whether a reply is currently being displayed
// in a given Puppeteer page. It does so by looking for the presence
// of the string "Stop generating" in the HTML content of the main
// element on the page. If the string is found, it returns true,
// indicating that a reply is being displayed. Otherwise, it returns
// false.
async function is_replying (page) {
    // Note: This code assumes that `Stop generating' appers during
    // the reply is being displayed.
    const main = await page.$('main');
    const html = await page.evaluate(b => b.innerHTML, main);
    return html.includes('Stop generating');
}

// This function takes a string buf as input and fills the textarea in
// the ChatGPT page with that string, and submits the form. The
// function internally calls current_page() function to get the
// Puppeteer page object, then finds the textarea element in the page,
// modifies its value to the given string, and simulates pressing the
// Enter key to submit the form. There is no explicit return value.
async function send (buf) {
    // Fill the textarea with string BUF and submit the form.
    const page = await current_page();
    const text = await page.$('textarea');
    // Directly modify the value of textarea.
    // https://stackoverflow.com/questions/47966510/how-to-fill-an-input-field-using-puppeteer
    await page.$eval('textarea', (el, buf) => el.value = buf, buf);
    await text.press('Enter');
}

// The recv function extracts the reply from the current page and
// converts it to plain text using the convert library. If the debug
// flag is set, it prints the HTML reply instead of the plain text
// version. It also replaces consecutive newlines with a single
// newline. Finally, if the reply is finished, it prints EOF to
// indicate the end of the reply. The function does not take any
// arguments and has no return value.
async function recv (debug) {
    const page = await current_page();
    let html = await extract_reply(page);
    html = html.replaceAll(/<button.*?<\/button>/g, '');
    let text = convert.convert(html, {
        preserveNewlines: true,
        wordwrap: false,
    });
    if (debug)
	text = html;
    text = text.replaceAll(/\n{3,}/g, '\n\n');
    console.log(text)
    if (!await is_replying(page)) {
	console.log('\nEOF')
    }
}

// argv[2] is the first user-specified argument.
const mode = process.argv[2];
const debug = (process.argv.length >= 4);

if (mode == '-i') {
    (async () => {
	const page = await current_page();
	await page.reload();
	process.exit(0);
    })();
}

// Send mode.
if (mode == '-s') {
    // Read lines from STDIN.
    const rl = readline.createInterface({
	input: process.stdin,
	output: process.stdout
    });
    let buf = '';
    rl.on('line', function (line) {
	buf += line + '\n';
    });
    rl.on('close', function() {
	(async () => {
	    await send(buf);
	    process.exit(0);
	})();
    });
}

// Receive mode.
if (mode == '-r') {
    (async () => {
	await recv(debug);
	process.exit(0);
    })();
}
